<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulatore di Mappe di Guerra (PvP)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .sidebar {
            width: 350px;
            max-height: 100vh;
            overflow-y: auto;
        }
        #map-wrapper {
            position: relative;
            width: 100%;
            height: 100vh;
            background-color: #333;
            overflow: hidden; /* Nasconde l'overflow del panning della mappa */
        }
        #map-canvas {
            display: block;
            background-color: #eee; /* Sfondo di fallback */
            cursor: grab; /* Cursore predefinito per il panning */
            touch-action: none; /* Impedisce il comportamento predefinito del browser per il touch */
        }
        #map-canvas.grabbing {
            cursor: grabbing; /* Cursore quando si sta facendo panning attivo */
        }
        .unit-icon-svg {
            width: 32px;
            height: 32px;
            stroke-width: 1.5;
        }
        .turn-indicator {
            transition: all 0.3s ease-in-out;
        }
        .sidebar::-webkit-scrollbar { width: 8px; }
        .sidebar::-webkit-scrollbar-track { background: #2d3748; }
        .sidebar::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 10px;
            border: 2px solid #2d3748;
        }
        #game-messages {
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.85rem;
        }
        #game-messages::-webkit-scrollbar { width: 6px; }
        #game-messages::-webkit-scrollbar-track { background: #1a202c; }
        #game-messages::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 6px;
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex overflow-hidden">

    <!-- Sidebar dei Controlli -->
    <div id="sidebar" class="sidebar bg-gray-900 p-4 shadow-lg flex flex-col space-y-4 flex-shrink-0">
        <h1 class="text-2xl font-bold text-center text-blue-400">Simulatore di Guerra</h1>

        <!-- Selezione Linea Temporale -->
        <div>
            <label for="timeline-select" class="block text-sm font-medium text-gray-400 mb-1">Seleziona Linea Temporale</label>
            <select id="timeline-select" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="ww2">Seconda Guerra Mondiale</option>
                <option value="roman">Impero Romano</option>
                <option value="fantasy">Regno Fantasy</option>
                <option value="custom">Sandbox Globale</option>
            </select>
        </div>

        <!-- Gestione Turno e Statistiche -->
        <div class="bg-gray-800 p-3 rounded-lg">
            <h2 class="text-lg font-semibold mb-2 text-center">Gestione Turno</h2>
            <div class="flex justify-center items-center space-x-4 mb-3">
                <div id="player-turn-indicator" class="turn-indicator p-2 rounded-lg bg-blue-600 border-2 border-blue-400 shadow-md">
                    <span class="font-bold">Turno Giocatore</span>
                </div>
                <div id="enemy-turn-indicator" class="turn-indicator p-2 rounded-lg bg-gray-700 border-2 border-gray-600">
                    <span class="font-bold text-gray-400">Turno Nemico</span>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-2 mb-3 text-sm">
                <div>Morti Giocatore: <span id="player-deaths" class="font-bold text-red-400">0</span></div>
                <div class="text-right">Morti Nemico: <span id="enemy-deaths" class="font-bold text-red-400">0</span></div>
            </div>
            <button id="end-turn-btn" class="w-full mt-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Termina Turno</button>
            <button id="reset-map-btn" class="w-full mt-2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Reset Mappa</button>
        </div>

        <!-- Palette Unità Disponibili -->
        <div id="unit-palette" class="flex-grow bg-gray-800 p-3 rounded-lg">
            <h2 class="text-lg font-semibold mb-3 text-center">Unità Disponibili</h2>
            <div id="unit-list" class="grid grid-cols-3 gap-4 text-center">
                <!-- Le unità verranno popolate dinamicamente qui -->
            </div>
        </div>

        <!-- Strumenti di Creazione Mappa (solo per Sandbox Globale e Regno Fantasy) -->
        <div id="map-creation-tools" class="bg-gray-800 p-3 rounded-lg hidden">
            <h2 class="text-lg font-semibold mb-3 text-center">Strumenti Mappa</h2>
            <div class="flex items-center justify-between mb-2">
                <label for="drawing-mode-toggle" class="block text-sm font-medium text-gray-400">Modalità Disegno Manuale:</label>
                <input type="checkbox" id="drawing-mode-toggle" class="toggle toggle-primary" />
            </div>
            <button id="generate-random-map-btn" class="w-full mt-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300">Genera Mappa Casuale</button>
            <div id="terrain-palette" class="grid grid-cols-3 gap-2 mt-3 hidden">
                <button data-terrain="grass" class="terrain-button p-2 rounded-md bg-green-700 hover:bg-green-600 transition text-sm">Erba</button>
                <button data-terrain="water" class="terrain-button p-2 rounded-md bg-blue-700 hover:bg-blue-600 transition text-sm">Acqua</button>
                <button data-terrain="mountain" class="terrain-button p-2 rounded-md bg-gray-600 hover:bg-gray-500 transition text-sm">Montagna</button>
                <button data-terrain="forest" class="terrain-button p-2 rounded-md bg-green-900 hover:bg-green-800 transition text-sm">Foresta</button>
                <button data-terrain="desert" class="terrain-button p-2 rounded-md bg-yellow-700 hover:bg-yellow-600 transition text-sm">Deserto</button>
            </div>
        </div>

        <!-- Messaggi di Gioco -->
        <div class="bg-gray-800 p-3 rounded-lg">
            <h2 class="text-lg font-semibold mb-2 text-center">Messaggi di Gioco</h2>
            <div id="game-messages" class="bg-gray-900 p-2 rounded-md text-gray-300">
                <!-- I messaggi verranno visualizzati qui -->
            </div>
        </div>
        
        <!-- Istruzioni -->
        <div class="bg-gray-800 p-3 rounded-lg text-sm text-gray-300">
            <h3 class="font-semibold text-center mb-2">Come si Usa</h3>
            <ul class="list-disc list-inside space-y-1">
                <li>Scegli una linea temporale per caricare mappa e scenario.</li>
                <li>Clicca/Tocca un'unità nella palette per selezionarla e posizionarla.</li>
                <li>Clicca/Tocca un'unità sulla mappa per selezionarla.</li>
                <li>Le celle verdi indicano il movimento, le rosse l'attacco.</li>
                <li>Clicca/Tocca su una cella verde per muovere l'unità selezionata.</li>
                <li>Clicca/Tocca su una cella rossa (con unità nemica) per attaccare.</li>
                <li>Clicca col tasto destro/Premi a lungo su un'unità per rimuoverla.</li>
                <li>In "Sandbox Globale" o "Regno Fantasy", usa "Genera Mappa Casuale" per creare un nuovo campo di battaglia.</li>
                <li>Trascina la mappa con il mouse/un dito, usa la rotellina/pizzica per lo zoom.</li>
            </ul>
        </div>
    </div>

    <!-- Contenitore della Mappa Canvas -->
    <div id="map-wrapper" class="flex-grow">
        <canvas id="map-canvas"></canvas>
    </div>

    <script>
        // --- STATO GLOBALE DELL'APPLICAZIONE ---
        const app = {
            canvas: null,
            ctx: null,
            markers: [], // Array di oggetti unità
            selectedUnitType: null, // Tipo di unità selezionata dalla palette
            selectedUnit: null, // Oggetto unità attualmente selezionato sulla mappa
            isPlayerTurn: true,
            nextUnitId: 0,
            currentTimeline: 'ww2',
            mapImage: new Image(), // Per mappe predefinite (es. mappa del mondo)
            iconCache: {}, // Cache per icone pre-renderizzate
            unitSize: 40, // Dimensione delle unità in pixel (visuale, non di griglia)
            playerDeaths: 0,
            enemyDeaths: 0,
            gameMessages: [],
            maxGameMessages: 10,
            lastFrameTime: 0, // Per il calcolo del delta time
            
            // Panning e Zoom della Mappa
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0,

            // Sistema a Griglia
            cellSize: 50, // Dimensione di ogni cella della griglia in pixel
            gridWidth: 0, // Larghezza della griglia in celle
            gridHeight: 0, // Altezza della griglia in celle

            // Disegno della Mappa (per timeline personalizzata/casuale)
            drawingMode: false, // Indica se è attiva la modalità di disegno manuale
            selectedTerrain: 'grass', // 'grass', 'water', 'mountain', 'forest', 'desert'
            terrainGrid: [], // Memorizza i dati del terreno per la mappa personalizzata (array 2D)
            terrainColors: {
                grass: '#547494',    // Verde/blu più scuro per la terra
                water: '#add3d6',    // Blu più chiaro per l'acqua
                mountain: '#8B4513', // Marrone sella per le montagne
                forest: '#345c3b',   // Verde scuro per la foresta
                desert: '#d4a373'    // Marrone chiaro per il deserto
            },
            terrainTileImages: {}, // Cache per le immagini delle tessere del terreno
            isDrawing: false, // Flag per il disegno manuale

            // Evidenziazione Celle
            highlightedMoveCells: [],
            highlightedAttackCells: [],

            // Gestione Touch per Long Press (simulazione tasto destro)
            touchStartTime: 0,
            touchStartX: 0,
            touchStartY: 0,
            LONG_PRESS_THRESHOLD: 500, // ms
            TAP_MOVE_THRESHOLD: 10, // pixels
        };

        // Placeholder per un'immagine della mappa del mondo.
        // In un'applicazione reale, caricheresti qui un'immagine della mappa del mondo ad alta risoluzione.
        const WORLD_MAP_PLACEHOLDER = 'https://placehold.co/1000x700/5a6d89/ffffff?text=Mappa+Mondo';

        // --- DATI E CONFIGURAZIONE ---
        // Icone SVG per le unità. I colori di riempimento e tratto sono segnaposto, sostituiti dinamicamente.
        const SVG_ICONS = {
            ww2_infantry: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>`,
            ww2_tank: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 9.5h1.1a1 1 0 0 1 .9.5L5 12v4H2Z"/><path d="M22 9.5h-1.1a1 1 0 0 0-.9.5L19 12v4h3Z"/><path d="M5 16h14V9H5v7Z"/><path d="M5 9V7a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v2"/><path d="M12 16v-4"/><path d="M9 12h6"/></svg>`,
            roman_legion: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>`,
            roman_cavalry: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L9 9h6l-3-7z"/><path d="M3 12h18"/><path d="M5 21l7-9 7 9"/></svg>`,
            fantasy_knight: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l-5 10h10l-5-10zM12 9v12M5 16h14M3 12h18"/></svg>`, // Simple knight
            fantasy_archer: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 12H2M18 12h-8M12 2v20M22 12l-3-3m0 6l3-3"/></svg>`, // Simple bow
            fantasy_mage: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l-5 10h10l-5-10zM5 12h14M12 12v10M16 16l-4 4-4-4"/></svg>`, // Simple staff/magic
        };

        const MAP_DATA = {
            ww2: WORLD_MAP_PLACEHOLDER, // Usa la mappa del mondo per la Seconda Guerra Mondiale
            roman: WORLD_MAP_PLACEHOLDER, // Usa la mappa del mondo per l'Impero Romano
            fantasy: 'random', // Indica che la mappa sarà generata casualmente
            custom: 'random', // Indica che la mappa sarà generata casualmente (o disegnata)
        };

        const TIMELINES = {
            ww2: {
                name: 'Seconda Guerra Mondiale',
                mapId: 'ww2',
                units: {
                    ww2_infantry: { name: 'Fanteria WW2', health: 100, attack: 20, movementRange: 3, attackRange: 1, maxMP: 3, maxAP: 1 },
                    ww2_tank: { name: 'Carro Armato WW2', health: 200, attack: 50, movementRange: 2, attackRange: 1, maxMP: 2, maxAP: 1 },
                },
                initialUnits: [ // Unità da distribuire equamente (totale 10)
                    { type: 'ww2_tank', count: 4 }, // 2 per giocatore
                    { type: 'ww2_infantry', count: 6 }, // 3 per giocatore
                ]
            },
            roman: {
                name: 'Impero Romano',
                mapId: 'roman',
                units: {
                    roman_legion: { name: 'Legione Romana', health: 120, attack: 25, movementRange: 4, attackRange: 1, maxMP: 4, maxAP: 1 },
                    roman_cavalry: { name: 'Cavalleria Romana', health: 80, attack: 30, movementRange: 6, attackRange: 1, maxMP: 6, maxAP: 1 },
                },
                initialUnits: [ // Totale 10
                    { type: 'roman_legion', count: 6 }, // 3 per giocatore
                    { type: 'roman_cavalry', count: 4 }, // 2 per giocatore
                ]
            },
            fantasy: {
                name: 'Regno Fantasy',
                mapId: 'fantasy', // Mappa casuale per il fantasy
                units: {
                    fantasy_knight: { name: 'Cavaliere', health: 150, attack: 30, movementRange: 3, attackRange: 1, maxMP: 3, maxAP: 1 },
                    fantasy_archer: { name: 'Arciere', health: 80, attack: 25, movementRange: 2, attackRange: 3, maxMP: 2, maxAP: 1 },
                    fantasy_mage: { name: 'Mago', health: 70, attack: 40, movementRange: 2, attackRange: 2, maxMP: 2, maxAP: 1 },
                },
                initialUnits: [ // Totale 10
                    { type: 'fantasy_knight', count: 4 }, // 2 per giocatore
                    { type: 'fantasy_archer', count: 4 }, // 2 per giocatore
                    { type: 'fantasy_mage', count: 2 }, // 1 per giocatore
                ]
            },
            custom: {
                name: 'Sandbox Globale',
                mapId: 'custom', // Mappa casuale o disegnabile
                units: {
                    ww2_infantry: { name: 'Fanteria WW2', health: 100, attack: 20, movementRange: 3, attackRange: 1, maxMP: 3, maxAP: 1 },
                    ww2_tank: { name: 'Carro Armato WW2', health: 200, attack: 50, movementRange: 2, attackRange: 1, maxMP: 2, maxAP: 1 },
                    roman_legion: { name: 'Legione Romana', health: 120, attack: 25, movementRange: 4, attackRange: 1, maxMP: 4, maxAP: 1 },
                    roman_cavalry: { name: 'Cavalleria Romana', health: 80, attack: 30, movementRange: 6, attackRange: 1, maxMP: 6, maxAP: 1 },
                    fantasy_knight: { name: 'Cavaliere', health: 150, attack: 30, movementRange: 3, attackRange: 1, maxMP: 3, maxAP: 1 },
                    fantasy_archer: { name: 'Arciere', health: 80, attack: 25, movementRange: 2, attackRange: 3, maxMP: 2, maxAP: 1 },
                    fantasy_mage: { name: 'Mago', health: 70, attack: 40, movementRange: 2, attackRange: 2, maxMP: 2, maxAP: 1 },
                },
                initialUnits: [] // Inizia vuoto per la creazione personalizzata, le unità vanno piazzate manualmente
            }
        };

        // --- INIZIALIZZAZIONE E LOOP PRINCIPALE ---
        async function initializeApp() {
            app.canvas = document.getElementById('map-canvas');
            app.ctx = app.canvas.getContext('2d');

            setupEventListeners();
            await preloadAllIcons();
            await preloadTerrainTiles(); // Precarica le immagini delle tessere del terreno
            
            resizeCanvas();
            loadTimeline(app.currentTimeline);
            app.lastFrameTime = performance.now(); // Inizializza lastFrameTime
            gameLoop();
        }

        function gameLoop(currentTime) {
            const deltaTime = (currentTime - app.lastFrameTime) / 1000; // Converti in secondi
            app.lastFrameTime = currentTime;

            update(deltaTime); // Aggiorna lo stato del gioco (es. movimento unità)
            render(); // Disegna tutto sulla tela
            
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            // Aggiorna le unità in movimento
            app.markers.forEach(marker => {
                if (marker.path && marker.path.length > 0) {
                    const targetGridX = marker.path[0].x;
                    const targetGridY = marker.path[0].y;

                    const targetPixelX = targetGridX * app.cellSize + app.cellSize / 2;
                    const targetPixelY = targetGridY * app.cellSize + app.cellSize / 2;

                    const dx = targetPixelX - marker.x;
                    const dy = targetPixelY - marker.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const movementSpeed = 200; // Pixel al secondo
                    const step = movementSpeed * deltaTime;

                    if (distance > step) {
                        marker.x += (dx / distance) * step;
                        marker.y += (dy / distance) * step;
                    } else {
                        // Raggiunto il centro della cella target, passa alla prossima cella nel percorso
                        marker.x = targetPixelX;
                        marker.y = targetPixelY;
                        marker.gridX = targetGridX;
                        marker.gridY = targetGridY;
                        marker.path.shift(); // Rimuovi la cella corrente dal percorso

                        if (marker.path.length === 0) {
                            marker.moving = false;
                            addGameMessage(`Unità ${marker.id} ha raggiunto la destinazione.`);
                        }
                    }
                }
            });
        }

        function render() {
            if (!app.canvas || !app.ctx) return;
            const { ctx, canvas } = app;

            // Pulisci la tela
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Applica trasformazioni globali per panning e zoom
            ctx.save();
            ctx.translate(app.offsetX, app.offsetY);
            ctx.scale(app.scale, app.scale);

            // 1. Disegna la mappa di sfondo o il terreno personalizzato
            if (MAP_DATA[app.currentTimeline] === 'random') {
                drawCustomTerrain(); // Disegna le tessere del terreno generate casualmente
            } else if (app.mapImage.complete) {
                // Disegna l'immagine della mappa per riempire la vista scalata
                ctx.drawImage(app.mapImage, 0, 0, canvas.width / app.scale, canvas.height / app.scale);
            }

            // 2. Disegna la griglia (opzionale, per debug o visualizzazione)
            drawGrid();

            // 3. Disegna le celle evidenziate (movimento/attacco)
            drawHighlightedCells();

            // 4. Disegna le unità
            app.markers.forEach(marker => {
                const icon = app.iconCache[`${marker.unitType}_${marker.faction}`];
                if (!icon) return;

                const isCorrectTurn = (app.isPlayerTurn && marker.faction === 'player') || (!app.isPlayerTurn && marker.faction === 'enemy');
                ctx.globalAlpha = isCorrectTurn ? 1.0 : 0.6; // Oscura le unità non attive in questo turno

                // Disegna l'icona dell'unità
                // Le unità sono centrate nella loro cella di griglia
                const pixelX = marker.x - app.unitSize / 2;
                const pixelY = marker.y - app.unitSize / 2;
                ctx.drawImage(icon, pixelX, pixelY, app.unitSize, app.unitSize);
                
                // Disegna il cerchio di selezione se l'unità è selezionata
                if (app.selectedUnit && app.selectedUnit.id === marker.id) {
                    ctx.beginPath();
                    ctx.arc(marker.x, marker.y, app.unitSize / 2 + 4, 0, Math.PI * 2);
                    ctx.strokeStyle = '#facc15'; // Giallo
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Disegna la barra della salute
                drawHealthBar(ctx, marker);

                ctx.globalAlpha = 1.0; // Ripristina l'alpha
            });

            ctx.restore(); // Ripristina lo stato originale della tela (annulla traslazione/scala)
        }

        function drawGrid() {
            const { ctx, cellSize, gridWidth, gridHeight } = app;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // Colore della griglia semi-trasparente
            ctx.lineWidth = 1;

            for (let x = 0; x < gridWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellSize, 0);
                ctx.lineTo(x * cellSize, gridHeight * cellSize);
                ctx.stroke();
            }

            for (let y = 0; y < gridHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellSize);
                ctx.lineTo(gridWidth * cellSize, y * cellSize);
                ctx.stroke();
            }
        }

        function drawHighlightedCells() {
            const { ctx, cellSize, highlightedMoveCells, highlightedAttackCells } = app;

            // Celle di movimento (verdi)
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)'; // Verde semi-trasparente
            highlightedMoveCells.forEach(cell => {
                ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
            });

            // Celle di attacco (rosse)
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Rosso semi-trasparente
            highlightedAttackCells.forEach(cell => {
                ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
            });
        }

        function drawHealthBar(ctx, marker) {
            const barWidth = app.unitSize * 0.8;
            const barHeight = 5;
            const barX = marker.x - barWidth / 2;
            const barY = marker.y + app.unitSize / 2 + 5; // Sotto l'unità

            // Sfondo della barra della salute
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Salute attuale
            const healthPercentage = marker.health / marker.maxHealth;
            const currentHealthWidth = barWidth * healthPercentage;
            ctx.fillStyle = healthPercentage > 0.5 ? '#22c55e' : (healthPercentage > 0.2 ? '#eab308' : '#ef4444'); // Verde, Giallo, Rosso
            ctx.fillRect(barX, barY, currentHealthWidth, barHeight);

            // Bordo
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        function drawCustomTerrain() {
            const { ctx, cellSize, gridWidth, gridHeight, terrainGrid } = app;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const terrainType = terrainGrid[y][x];
                    const img = app.terrainTileImages[terrainType];
                    if (img && img.complete) {
                        ctx.drawImage(img, x * cellSize, y * cellSize, cellSize, cellSize);
                    } else {
                        // Fallback a colore solido se l'immagine non è caricata
                        ctx.fillStyle = app.terrainColors[terrainType] || '#000';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        // --- GESTIONE EVENTI ---
        function setupEventListeners() {
            document.getElementById('timeline-select').addEventListener('change', (e) => loadTimeline(e.target.value));
            document.getElementById('end-turn-btn').addEventListener('click', toggleTurn);
            document.getElementById('reset-map-btn').addEventListener('click', resetCurrentTimeline);
            
            // Eventi mouse per desktop
            app.canvas.addEventListener('click', handleMapClick);
            app.canvas.addEventListener('contextmenu', handleMapRightClick);
            app.canvas.addEventListener('mousedown', handleMouseDown);
            app.canvas.addEventListener('mousemove', handleMouseMove);
            app.canvas.addEventListener('mouseup', handleMouseUp);
            app.canvas.addEventListener('mouseout', handleMouseUp); // Ferma il trascinamento se il mouse esce dalla tela
            app.canvas.addEventListener('wheel', handleMouseWheel);

            // Eventi touch per mobile
            app.canvas.addEventListener('touchstart', handleTouchStart);
            app.canvas.addEventListener('touchmove', handleTouchMove);
            app.canvas.addEventListener('touchend', handleTouchEnd);
            app.canvas.addEventListener('touchcancel', handleTouchEnd); // Gestisce quando il tocco è interrotto

            window.addEventListener('resize', resizeCanvas);

            // Strumenti di Creazione Mappa (solo per Sandbox Globale e Regno Fantasy)
            document.getElementById('generate-random-map-btn').addEventListener('click', () => {
                generateRandomTerrainMap();
                addGameMessage('Mappa casuale generata per la modalità Sandbox/Fantasy.');
            });
            // La modalità disegno manuale non è più attiva di default per le mappe casuali
            // ma il toggle e la palette sono mantenuti per un potenziale futuro uso di disegno manuale
            document.getElementById('drawing-mode-toggle').addEventListener('change', (e) => {
                app.drawingMode = e.target.checked;
                const terrainPalette = document.getElementById('terrain-palette');
                if (app.drawingMode) {
                    terrainPalette.classList.remove('hidden');
                    addGameMessage('Modalità Disegno Manuale Abilitata (solo per Sandbox).');
                } else {
                    terrainPalette.classList.add('hidden');
                    addGameMessage('Modalità Disegno Manuale Disabilitata.');
                }
            });
            document.querySelectorAll('.terrain-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    app.selectedTerrain = e.target.dataset.terrain;
                    document.querySelectorAll('.terrain-button').forEach(btn => btn.classList.remove('ring-2', 'ring-yellow-400'));
                    e.target.classList.add('ring-2', 'ring-yellow-400');
                    addGameMessage(`Terreno selezionato: ${e.target.innerText}`);
                });
            });
            // Selezione iniziale per il pulsante del terreno
            document.querySelector('.terrain-button[data-terrain="grass"]').classList.add('ring-2', 'ring-yellow-400');
        }

        function resizeCanvas() {
            const wrapper = document.getElementById('map-wrapper');
            const oldCanvasWidth = app.canvas.width;
            const oldCanvasHeight = app.canvas.height;
            
            app.canvas.width = wrapper.offsetWidth;
            app.canvas.height = wrapper.offsetHeight;
            
            // Ricalcola le dimensioni della griglia
            app.gridWidth = Math.floor(app.canvas.width / app.cellSize);
            app.gridHeight = Math.floor(app.canvas.height / app.cellSize);

            // Regola gli offset per mantenere il centro relativamente stabile durante il ridimensionamento della finestra
            if (oldCanvasWidth > 0 && oldCanvasHeight > 0) {
                app.offsetX += (app.canvas.width - oldCanvasWidth) / 2;
                app.offsetY += (app.canvas.height - oldCanvasHeight) / 2;
            }

            // Se la mappa è generata casualmente, rigenerala per adattarsi alle nuove dimensioni
            if (MAP_DATA[app.currentTimeline] === 'random') {
                generateRandomTerrainMap();
            }
        }

        function getMousePos(event) {
            const rect = app.canvas.getBoundingClientRect();
            // Regola la posizione del mouse in base al panning e allo zoom attuali
            const x = (event.clientX - rect.left - app.offsetX) / app.scale;
            const y = (event.clientY - rect.top - app.offsetY) / app.scale;

            // Calcola le coordinate della griglia
            const gridX = Math.floor(x / app.cellSize);
            const gridY = Math.floor(y / app.cellSize);

            return { x, y, gridX, gridY };
        }

        function handleMouseDown(event) {
            if (event.button === 0) { // Click sinistro per trascinare/disegnare
                if (app.currentTimeline === 'custom' && app.drawingMode) {
                    app.isDrawing = true;
                    drawTerrainAt(getMousePos(event));
                } else {
                    app.isDragging = true;
                    app.lastMouseX = event.clientX;
                    app.lastMouseY = event.clientY;
                    app.canvas.classList.add('grabbing');
                }
            }
        }

        function handleMouseMove(event) {
            if (app.isDragging) {
                const dx = event.clientX - app.lastMouseX;
                const dy = event.clientY - app.lastMouseY;
                app.offsetX += dx;
                app.offsetY += dy;
                app.lastMouseX = event.clientX;
                app.lastMouseY = event.clientY;
            } else if (app.isDrawing && app.currentTimeline === 'custom' && app.drawingMode) {
                drawTerrainAt(getMousePos(event));
            }
        }

        function handleMouseUp(event) {
            app.isDragging = false;
            app.isDrawing = false;
            app.canvas.classList.remove('grabbing');
        }

        function handleMouseWheel(event) {
            event.preventDefault(); // Impedisci lo scorrimento della pagina
            const scaleAmount = 1.1;
            const mousePos = getMousePos(event); // Posizione del mouse relativa alla tela non scalata

            const oldScale = app.scale;
            if (event.deltaY < 0) { // Zoom in
                app.scale *= scaleAmount;
            } else { // Zoom out
                app.scale /= scaleAmount;
            }

            // Limita lo zoom
            app.scale = Math.max(0.5, Math.min(app.scale, 3.0));

            // Regola l'offset per zoomare verso il cursore del mouse
            app.offsetX = mousePos.x * (oldScale - app.scale) + app.offsetX;
            app.offsetY = mousePos.y * (oldScale - app.scale) + app.offsetY;
        }

        // --- Gestione Touch ---
        function handleTouchStart(event) {
            event.preventDefault(); // Impedisci il comportamento predefinito del browser (scorrimento, zoom)
            if (event.touches.length === 1) {
                app.isDragging = true;
                app.lastMouseX = event.touches[0].clientX;
                app.lastMouseY = event.touches[0].clientY;
                app.canvas.classList.add('grabbing');

                app.touchStartTime = performance.now();
                app.touchStartX = event.touches[0].clientX;
                app.touchStartY = event.touches[0].clientY;
            }
            // Per il pinch-to-zoom (più complesso, non implementato completamente qui)
            // if (event.touches.length === 2) { /* gestisci l'inizio del pinch */ }
        }

        function handleTouchMove(event) {
            if (event.touches.length === 1 && app.isDragging) {
                const dx = event.touches[0].clientX - app.lastMouseX;
                const dy = event.touches[0].clientY - app.lastMouseY;
                app.offsetX += dx;
                app.offsetY += dy;
                app.lastMouseX = event.touches[0].clientX;
                app.lastMouseY = event.touches[0].clientY;
            }
            // Per il pinch-to-zoom
            // if (event.touches.length === 2) { /* gestisci il movimento del pinch */ }
        }

        function handleTouchEnd(event) {
            app.isDragging = false;
            app.canvas.classList.remove('grabbing');

            // Controlla il tap (equivalente al click)
            if (event.changedTouches.length === 1) {
                const touchDuration = performance.now() - app.touchStartTime;
                const touchEndX = event.changedTouches[0].clientX;
                const touchEndY = event.changedTouches[0].clientY;
                const moveDistance = Math.sqrt(
                    Math.pow(touchEndX - app.touchStartX, 2) +
                    Math.pow(touchEndY - app.touchStartY, 2)
                );

                if (touchDuration < app.LONG_PRESS_THRESHOLD && moveDistance < app.TAP_MOVE_THRESHOLD) {
                    // È un tap, simula il click
                    const simulatedEvent = new MouseEvent('click', {
                        clientX: touchEndX,
                        clientY: touchEndY,
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    app.canvas.dispatchEvent(simulatedEvent);
                } else if (touchDuration >= app.LONG_PRESS_THRESHOLD && moveDistance < app.TAP_MOVE_THRESHOLD) {
                    // È una pressione prolungata, simula il click destro
                    const simulatedEvent = new MouseEvent('contextmenu', {
                        clientX: touchEndX,
                        clientY: touchEndY,
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    app.canvas.dispatchEvent(simulatedEvent);
                }
            }
        }


        function handleMapClick(event) {
            const pos = getMousePos(event);
            const clickedGridX = pos.gridX;
            const clickedGridY = pos.gridY;

            // Se in modalità disegno manuale (solo per custom e se abilitata), disegna il terreno
            if (app.currentTimeline === 'custom' && app.drawingMode) {
                drawTerrainAt(pos);
                return; // Non fare nient'altro se si sta disegnando
            }

            const clickedUnit = getUnitAtGridPos(clickedGridX, clickedGridY);

            if (app.selectedUnit) {
                // Un'unità è già selezionata, ora l'utente vuole muoverla o attaccare
                if (app.highlightedAttackCells.some(c => c.x === clickedGridX && c.y === clickedGridY)) {
                    // Cliccato su una cella di attacco evidenziata
                    if (clickedUnit && clickedUnit.faction !== app.selectedUnit.faction) {
                        handleCombat(app.selectedUnit, clickedUnit);
                    } else {
                        addGameMessage("Non puoi attaccare una cella vuota o un'unità amica.");
                    }
                } else if (app.highlightedMoveCells.some(c => c.x === clickedGridX && c.y === clickedGridY)) {
                    // Cliccato su una cella di movimento evidenziata
                    if (!clickedUnit) { // Solo se la cella di destinazione è vuota
                        startMoveUnit(app.selectedUnit, clickedGridX, clickedGridY);
                    } else {
                        addGameMessage("La cella di destinazione è occupata.");
                    }
                } else if (app.selectedUnit.gridX === clickedGridX && app.selectedUnit.gridY === clickedGridY) {
                    // Cliccato sull'unità selezionata, deseleziona
                    deselectAll();
                } else {
                    addGameMessage('Destinazione non valida per l\'unità selezionata.');
                    deselectAll();
                }
            } else if (clickedUnit) {
                // Nessuna unità selezionata, cliccato su un'unità -> seleziona
                handleUnitSelection(clickedUnit);
            } else if (app.selectedUnitType) {
                // Nessuna unità selezionata, nessun'unità cliccata, ma un tipo di unità è selezionato dalla palette -> piazza unità
                const unitInfo = TIMELINES[app.currentTimeline].units[app.selectedUnitType];
                const faction = app.isPlayerTurn ? 'player' : 'enemy'; // Le unità piazzate dal giocatore attuale
                placeUnit(app.selectedUnitType, faction, clickedGridX, clickedGridY, unitInfo.health, unitInfo.attack, unitInfo.movementRange, unitInfo.attackRange, unitInfo.maxMP, unitInfo.maxAP);
            } else {
                // Cliccato su spazio vuoto senza unità selezionata o tipo selezionato
                deselectAll();
            }
        }

        function handleMapRightClick(event) {
            event.preventDefault(); // Impedisci il menu contestuale
            const pos = getMousePos(event);
            const clickedUnit = getUnitAtGridPos(pos.gridX, pos.gridY);
            if (clickedUnit) {
                removeUnit(clickedUnit);
                addGameMessage(`Unità ${clickedUnit.id} rimossa.`);
            }
            deselectAll(); // Deseleziona qualsiasi unità/tipo selezionato
        }

        // --- GESTIONE UNITÀ ---
        function placeUnit(unitType, faction, gridX, gridY, health, attack, movementRange, attackRange, maxMP, maxAP) {
            // Controlla se la cella è già occupata
            if (getUnitAtGridPos(gridX, gridY)) {
                addGameMessage("Non puoi posizionare un'unità su una cella già occupata.");
                return;
            }

            const id = app.nextUnitId++;
            const pixelX = gridX * app.cellSize + app.cellSize / 2;
            const pixelY = gridY * app.cellSize + app.cellSize / 2;

            app.markers.push({ 
                id, unitType, faction, 
                gridX, gridY, x: pixelX, y: pixelY, // Coordinate pixel iniziali centrate nella cella
                health: health, 
                maxHealth: health, 
                attack: attack, 
                movementRange: movementRange, // in celle
                attackRange: attackRange, // in celle
                maxMP: maxMP,
                currentMP: maxMP,
                maxAP: maxAP,
                currentAP: maxAP,
                hasMoved: false,
                hasAttacked: false,
                path: [], // Percorso per il movimento animato
                moving: false, // Flag per l'animazione di movimento
            });
            addGameMessage(`Unità ${unitType} (${faction}) posizionata a (${gridX}, ${gridY}).`);
            deselectAll();
        }

        function startMoveUnit(unit, targetGridX, targetGridY) {
            if (unit.hasMoved) {
                addGameMessage('Questa unità si è già mossa in questo turno.');
                deselectAll();
                return;
            }
            if (unit.currentMP <= 0) {
                addGameMessage('Questa unità non ha Punti Movimento sufficienti.');
                deselectAll();
                return;
            }

            // Semplice percorso diretto (potrebbe essere migliorato con A*)
            const path = [{ x: targetGridX, y: targetGridY }];
            unit.path = path;
            unit.moving = true;
            unit.hasMoved = true;
            unit.currentMP--; // Decrementa MP per ogni movimento (potrebbe essere più complesso per costi per cella)
            addGameMessage(`Unità ${unit.id} si muove verso (${targetGridX}, ${targetGridY}). MP rimanenti: ${unit.currentMP}.`);
            deselectAll(); // Deseleziona dopo aver dato l'ordine di movimento
        }

        function handleCombat(attacker, defender) {
            if (attacker.faction === defender.faction) {
                addGameMessage("Non puoi attaccare un'unità amica.");
                deselectAll();
                return;
            }
            if (attacker.hasAttacked) {
                addGameMessage('Questa unità si è già mossa o attaccata in questo turno.');
                deselectAll();
                return;
            }
            if (attacker.currentAP <= 0) {
                addGameMessage('Questa unità non ha Punti Azione sufficienti per attaccare.');
                deselectAll();
                return;
            }

            const distance = Math.abs(attacker.gridX - defender.gridX) + Math.abs(attacker.gridY - defender.gridY);
            if (distance > attacker.attackRange) {
                addGameMessage(`Unità ${attacker.id} è troppo lontana per attaccare Unità ${defender.id}. (Raggio: ${attacker.attackRange})`);
                deselectAll();
                return;
            }

            addGameMessage(`Combattimento: Unità ${attacker.id} (${attacker.unitType}) attacca Unità ${defender.id} (${defender.unitType})!`);

            // L'attaccante infligge danni al difensore
            defender.health -= attacker.attack;
            addGameMessage(`Unità ${defender.id} subisce ${attacker.attack} danni. Salute rimanente: ${defender.health}/${defender.maxHealth}.`);

            attacker.hasAttacked = true;
            attacker.currentAP--;

            if (defender.health <= 0) {
                addGameMessage(`Unità ${defender.id} (${defender.unitType}) distrutta!`);
                if (defender.faction === 'player') {
                    app.playerDeaths++;
                    document.getElementById('player-deaths').innerText = app.playerDeaths;
                } else {
                    app.enemyDeaths++;
                    document.getElementById('enemy-deaths').innerText = app.enemyDeaths;
                }
                removeUnit(defender);
            }
            deselectAll();
        }

        function removeUnit(markerToRemove) {
            app.markers = app.markers.filter(m => m.id !== markerToRemove.id);
            if (app.selectedUnit && app.selectedUnit.id === markerToRemove.id) {
                deselectAll();
            }
        }

        function handleUnitSelection(unit) {
            const isCorrectTurn = (app.isPlayerTurn && unit.faction === 'player') || (!app.isPlayerTurn && unit.faction === 'enemy');
            if (!isCorrectTurn) {
                addGameMessage('Non puoi selezionare questa unità in questo turno.');
                deselectAll();
                return;
            }

            deselectAll();
            app.selectedUnit = unit;
            addGameMessage(`Unità ${unit.id} (${unit.unitType}) selezionata. MP: ${unit.currentMP}, AP: ${unit.currentAP}.`);
            calculateHighlights(unit);
        }

        function getUnitAtGridPos(gridX, gridY) {
            return app.markers.find(m => m.gridX === gridX && m.gridY === gridY);
        }

        function deselectAll() {
            app.selectedUnit = null;
            app.selectedUnitType = null;
            app.highlightedMoveCells = [];
            app.highlightedAttackCells = [];
            // Rimuovi l'anello di selezione dai pulsanti della palette delle unità
            document.querySelectorAll('.unit-button').forEach(btn => btn.classList.remove('ring-2', 'ring-yellow-400'));
        }

        function calculateHighlights(unit) {
            app.highlightedMoveCells = [];
            app.highlightedAttackCells = [];

            if (!unit) return;

            // Calcola le celle di movimento
            if (!unit.hasMoved && unit.currentMP > 0) {
                for (let dy = -unit.movementRange; dy <= unit.movementRange; dy++) {
                    for (let dx = -unit.movementRange; dx <= unit.movementRange; dx++) {
                        const newX = unit.gridX + dx;
                        const newY = unit.gridY + dy;
                        // Controlla i limiti della griglia e la distanza Manhattan per il movimento
                        if (newX >= 0 && newX < app.gridWidth && newY >= 0 && newY < app.gridHeight &&
                            (Math.abs(dx) + Math.abs(dy) <= unit.movementRange) &&
                            !getUnitAtGridPos(newX, newY)) { // Non evidenziare celle occupate per il movimento
                            app.highlightedMoveCells.push({ x: newX, y: newY });
                        }
                    }
                }
            }

            // Calcola le celle di attacco
            if (!unit.hasAttacked && unit.currentAP > 0) {
                for (let dy = -unit.attackRange; dy <= unit.attackRange; dy++) {
                    for (let dx = -unit.attackRange; dx <= unit.attackRange; dx++) {
                        const newX = unit.gridX + dx;
                        const newY = unit.gridY + dy;
                        // Controlla i limiti della griglia e la distanza Manhattan per l'attacco
                        if (newX >= 0 && newX < app.gridWidth && newY >= 0 && newY < app.gridHeight &&
                            (Math.abs(dx) + Math.abs(dy) <= unit.attackRange)) {
                            const targetUnit = getUnitAtGridPos(newX, newY);
                            if (targetUnit && targetUnit.faction !== unit.faction) {
                                app.highlightedAttackCells.push({ x: newX, y: newY });
                            }
                        }
                    }
                }
            }
        }

        // --- GESTIONE TURNI E LINEE TEMPORALI ---
        function toggleTurn() {
            app.isPlayerTurn = !app.isPlayerTurn;
            deselectAll();
            updateTurnIndicators();
            addGameMessage(`È il turno del ${app.isPlayerTurn ? 'Giocatore' : 'Nemico'}.`);

            // Reset MP/AP per le unità della fazione che inizia il turno
            app.markers.forEach(marker => {
                if (marker.faction === (app.isPlayerTurn ? 'player' : 'enemy')) {
                    marker.currentMP = marker.maxMP;
                    marker.currentAP = marker.maxAP;
                    marker.hasMoved = false;
                    marker.hasAttacked = false;
                }
            });
        }
        
        function loadTimeline(timelineId) {
            app.currentTimeline = timelineId;
            const timeline = TIMELINES[timelineId];
            
            clearMap();
            resetDeaths();
            deselectAll();
            app.isPlayerTurn = true;
            updateTurnIndicators();
            
            // Mostra/nascondi gli strumenti di creazione mappa in base alla timeline
            const mapCreationTools = document.getElementById('map-creation-tools');
            const generateRandomMapBtn = document.getElementById('generate-random-map-btn');
            const drawingModeToggle = document.getElementById('drawing-mode-toggle');
            const terrainPalette = document.getElementById('terrain-palette');

            if (MAP_DATA[timelineId] === 'random') {
                mapCreationTools.classList.remove('hidden');
                generateRandomMapBtn.classList.remove('hidden');
                drawingModeToggle.checked = false; // Disabilita la modalità disegno manuale
                app.drawingMode = false;
                terrainPalette.classList.add('hidden'); // Nascondi la palette del terreno per il disegno manuale
                generateRandomTerrainMap(); // Genera una nuova mappa casuale
                addGameMessage(`Timeline "${timeline.name}" caricata con mappa casuale.`);
            } else {
                mapCreationTools.classList.add('hidden');
                generateRandomMapBtn.classList.add('hidden');
                drawingModeToggle.checked = false;
                app.drawingMode = false;
                terrainPalette.classList.add('hidden');
                // Per le mappe predefinite, ripristina la griglia del terreno a un tipo predefinito (non visibile)
                app.terrainGrid = Array(app.gridHeight).fill(0).map(() => Array(app.gridWidth).fill('grass'));
                addGameMessage(`Timeline "${timeline.name}" caricata.`);
            }

            // Carica l'immagine della mappa per le timeline non casuali
            if (MAP_DATA[timelineId] !== 'random') {
                app.mapImage.src = MAP_DATA[timeline.mapId];
                app.mapImage.onload = () => {
                    // Posiziona le unità dello scenario dopo che la mappa è stata caricata per garantire un ridimensionamento corretto
                    // Per le timeline con mappa predefinita, le unità sono piazzate in base allo scenario predefinito
                    if (timeline.scenario && timeline.scenario.length > 0) {
                        timeline.scenario.forEach(unitData => {
                            const gridX = Math.floor((unitData.x / 100) * app.gridWidth);
                            const gridY = Math.floor((unitData.y / 100) * app.gridHeight);
                            const unitInfo = timeline.units[unitData.type];
                            placeUnit(unitData.type, unitData.faction, gridX, gridY, unitInfo.health, unitInfo.attack, unitInfo.movementRange, unitInfo.attackRange, unitInfo.maxMP, unitInfo.maxAP);
                        });
                    } else { // Se non c'è uno scenario predefinito ma c'è initialUnits, distribuisci
                        distributeInitialUnits(timeline.initialUnits, timeline.units);
                    }
                }
            } else {
                // Per le mappe casuali, distribuisci le unità iniziali dopo la generazione della mappa
                distributeInitialUnits(timeline.initialUnits, timeline.units);
            }
            
            populateUnitPalette(timeline.units);
        }

        function distributeInitialUnits(initialUnitsConfig, unitDefinitions) {
            const playerUnitsToPlace = [];
            const enemyUnitsToPlace = [];

            initialUnitsConfig.forEach(unitTypeConfig => {
                const totalCount = unitTypeConfig.count;
                const playerCount = Math.ceil(totalCount / 2); // Arrotonda per eccesso per il giocatore 1
                const enemyCount = totalCount - playerCount;

                for (let i = 0; i < playerCount; i++) {
                    playerUnitsToPlace.push(unitTypeConfig.type);
                }
                for (let i = 0; i < enemyCount; i++) {
                    enemyUnitsToPlace.push(unitTypeConfig.type);
                }
            });

            // Mescola le unità per un posizionamento casuale
            shuffleArray(playerUnitsToPlace);
            shuffleArray(enemyUnitsToPlace);

            // Piazza le unità del giocatore (sinistra metà mappa)
            playerUnitsToPlace.forEach(unitType => {
                const unitInfo = unitDefinitions[unitType];
                let placed = false;
                let attempts = 0;
                const maxAttempts = 100; // Evita loop infiniti su mappe affollate

                while (!placed && attempts < maxAttempts) {
                    const gridX = Math.floor(Math.random() * (app.gridWidth / 2)); // Metà sinistra
                    const gridY = Math.floor(Math.random() * app.gridHeight);
                    if (!getUnitAtGridPos(gridX, gridY)) {
                        placeUnit(unitType, 'player', gridX, gridY, unitInfo.health, unitInfo.attack, unitInfo.movementRange, unitInfo.attackRange, unitInfo.maxMP, unitInfo.maxAP);
                        placed = true;
                    }
                    attempts++;
                }
                if (!placed) {
                    addGameMessage(`Attenzione: Impossibile posizionare l'unità ${unitType} per il giocatore.`);
                }
            });

            // Piazza le unità nemiche (destra metà mappa)
            enemyUnitsToPlace.forEach(unitType => {
                const unitInfo = unitDefinitions[unitType];
                let placed = false;
                let attempts = 0;
                const maxAttempts = 100;

                while (!placed && attempts < maxAttempts) {
                    const gridX = Math.floor(Math.random() * (app.gridWidth / 2)) + Math.ceil(app.gridWidth / 2); // Metà destra
                    const gridY = Math.floor(Math.random() * app.gridHeight);
                    if (!getUnitAtGridPos(gridX, gridY)) {
                        placeUnit(unitType, 'enemy', gridX, gridY, unitInfo.health, unitInfo.attack, unitInfo.movementRange, unitInfo.attackRange, unitInfo.maxMP, unitInfo.maxAP);
                        placed = true;
                    }
                    attempts++;
                }
                if (!placed) {
                    addGameMessage(`Attenzione: Impossibile posizionare l'unità ${unitType} per il nemico.`);
                }
            });
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Scambia gli elementi
            }
        }

        function resetCurrentTimeline() {
            addGameMessage(`Reset della timeline: ${TIMELINES[app.currentTimeline].name}`);
            loadTimeline(app.currentTimeline); // Ricarica la timeline corrente
        }

        function clearMap() {
            app.markers = [];
            app.nextUnitId = 0;
            app.terrainGrid = []; // Pulisci il terreno per le mappe personalizzate/casuali
        }

        function resetDeaths() {
            app.playerDeaths = 0;
            app.enemyDeaths = 0;
            document.getElementById('player-deaths').innerText = app.playerDeaths;
            document.getElementById('enemy-deaths').innerText = app.enemyDeaths;
        }
        
        // --- FUNZIONI DI UTILITÀ E GRAFICA ---
        async function preloadAllIcons() {
            const promises = [];
            // Itera attraverso tutti i possibili tipi di unità in tutte le timeline
            for (const timelineKey in TIMELINES) {
                for (const unitType in TIMELINES[timelineKey].units) {
                    ['player', 'enemy'].forEach(faction => {
                        const cacheKey = `${unitType}_${faction}`;
                        if (!app.iconCache[cacheKey]) {
                            promises.push(
                                new Promise(resolve => {
                                    const icon = new Image();
                                    const svgString = getIconSVG(unitType, faction);
                                    icon.src = 'data:image/svg+xml;base64,' + btoa(svgString);
                                    icon.onload = () => {
                                        app.iconCache[cacheKey] = icon;
                                        resolve();
                                    };
                                    icon.onerror = () => {
                                        console.error(`Failed to load icon for ${cacheKey}`);
                                        resolve(); // Risolvi comunque per non bloccare
                                    };
                                })
                            );
                        }
                    });
                }
            }
            return Promise.all(promises);
        }

        async function preloadTerrainTiles() {
            const promises = [];
            for (const type in app.terrainColors) {
                if (!app.terrainTileImages[type]) {
                    promises.push(new Promise(resolve => {
                        const img = new Image();
                        // Using placehold.co for colored squares as textures
                        img.src = `https://placehold.co/${app.cellSize}x${app.cellSize}/${app.terrainColors[type].substring(1)}/ffffff?text=`; // Remove # from color
                        img.onload = () => {
                            app.terrainTileImages[type] = img;
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load terrain tile for ${type}`);
                            resolve();
                        };
                    }));
                }
            }
            return Promise.all(promises);
        }

        function getIconSVG(unitType, faction) {
            const color = faction === 'player' ? '#3b82f6' : '#ef4444'; // Blu per giocatore, Rosso per nemico
            const strokeColor = '#ffffff'; // Tratto bianco per visibilità
            if (!SVG_ICONS[unitType]) return '';
            return SVG_ICONS[unitType]
                .replace(/stroke="currentColor"/g, `stroke="${strokeColor}"`)
                .replace(/fill="none"/g, `fill="${color}"`);
        }
        
        function populateUnitPalette(unitsConfig) {
            const unitList = document.getElementById('unit-list');
            unitList.innerHTML = ''; // Pulisci le unità precedenti

            for (const unitType in unitsConfig) {
                const unitInfo = unitsConfig[unitType];
                const unitDiv = document.createElement('div');
                unitDiv.className = 'flex flex-col items-center p-2 bg-gray-700 rounded-lg cursor-pointer hover:bg-gray-600 transition unit-button';
                
                unitDiv.innerHTML = `
                    <div class="unit-icon-svg">${getIconSVG(unitType, 'player')}</div>
                    <span class="text-xs mt-1">${unitInfo.name}</span>
                    <span class="text-xs text-gray-400">HP: ${unitInfo.health} ATK: ${unitInfo.attack}</span>
                    <span class="text-xs text-gray-400">MP: ${unitInfo.maxMP} AR: ${unitInfo.attackRange}</span>
                `;

                unitDiv.addEventListener('click', () => {
                    deselectAll();
                    app.selectedUnitType = unitType;
                    unitDiv.classList.add('ring-2', 'ring-yellow-400');
                    addGameMessage(`Unità "${unitInfo.name}" selezionata dalla palette.`);
                });
                unitList.appendChild(unitDiv);
            }
        }
        
        function updateTurnIndicators() {
            const playerIndicator = document.getElementById('player-turn-indicator');
            const enemyIndicator = document.getElementById('enemy-turn-indicator');
            if (app.isPlayerTurn) {
                playerIndicator.classList.replace('bg-gray-700', 'bg-blue-600');
                playerIndicator.classList.replace('border-gray-600', 'border-blue-400');
                playerIndicator.querySelector('span').classList.remove('text-gray-400');
                playerIndicator.classList.add('shadow-md');
                
                enemyIndicator.classList.replace('bg-red-600', 'bg-gray-700');
                enemyIndicator.classList.replace('border-red-400', 'border-gray-600');
                enemyIndicator.querySelector('span').classList.add('text-gray-400');
                enemyIndicator.classList.remove('shadow-md');
            } else {
                enemyIndicator.classList.replace('bg-gray-700', 'bg-red-600');
                enemyIndicator.classList.replace('border-red-400', 'border-gray-600');
                enemyIndicator.querySelector('span').classList.remove('text-gray-400');
                enemyIndicator.classList.add('shadow-md');

                playerIndicator.classList.replace('bg-blue-600', 'bg-gray-700');
                playerIndicator.classList.replace('border-blue-400', 'border-gray-600');
                playerIndicator.querySelector('span').classList.add('text-gray-400');
                playerIndicator.classList.remove('shadow-md');
            }
        }

        function addGameMessage(message) {
            const messageLog = document.getElementById('game-messages');
            const p = document.createElement('p');
            p.textContent = message;
            messageLog.prepend(p); // Aggiungi in cima
            
            // Mantieni solo gli ultimi N messaggi
            while (messageLog.children.length > app.maxGameMessages) {
                messageLog.removeChild(messageLog.lastChild);
            }
        }

        // --- FUNZIONI DI DISEGNO DELLA MAPPA PERSONALIZZATA/CASUALE ---
        function generateRandomTerrainMap() {
            app.terrainGrid = [];
            const terrainTypes = ['grass', 'water', 'mountain', 'forest', 'desert'];
            const commonTerrain = 'grass';
            const waterChance = 0.15; // 15% chance for water
            const mountainChance = 0.05; // 5% chance for mountain
            const forestChance = 0.1; // 10% chance for forest
            const desertChance = 0.05; // 5% chance for desert

            for (let y = 0; y < app.gridHeight; y++) {
                app.terrainGrid.push([]);
                for (let x = 0; x < app.gridWidth; x++) {
                    let chosenTerrain = commonTerrain;
                    const rand = Math.random();
                    if (rand < waterChance) {
                        chosenTerrain = 'water';
                    } else if (rand < waterChance + mountainChance) {
                        chosenTerrain = 'mountain';
                    } else if (rand < waterChance + mountainChance + forestChance) {
                        chosenTerrain = 'forest';
                    } else if (rand < waterChance + mountainChance + forestChance + desertChance) {
                        chosenTerrain = 'desert';
                    }
                    app.terrainGrid[y].push(chosenTerrain);
                }
            }
            addGameMessage('Mappa casuale generata.');
        }

        // Questa funzione è per il disegno manuale, non viene usata per le mappe casuali generate automaticamente
        function drawTerrainAt(pos) {
            const { terrainGrid, selectedTerrain, gridWidth, gridHeight } = app;
            const gridX = pos.gridX;
            const gridY = pos.gridY;

            if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                terrainGrid[gridY][gridX] = selectedTerrain;
            }
        }

        // --- ESECUZIONE SCRIPT ---
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
